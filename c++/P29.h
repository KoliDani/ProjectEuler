#pragma once
/*
Problem 29
Consider all integer combinations of a^b for 2 <= a <=5 and 2 <= b <= 5:
2^2 = 4,	2^3 = 8,	2^4 = 16,	2^5 = 32
3^2 = 9,	3^3 = 27,	3^4 = 81,	3^5 = 243
4^2 = 16,	4^3 = 64,	4^4 = 256,	4^5 = 1024
5^2 = 25,	5^3 = 125,	5^4 = 625,	5^5 = 3125
If they are then placed in numerical order, with any repeats removed, we get the
following sequence of  distinct terms:
4,8,9,16,25,27,32,64,81,125,243,256,625,1024,3125

How many distinct terms are in the sequence generated by a^b for 2 <= a <= 100 and 2 <= b <= 100?
*/

#include <string>;
#include <vector>;
#include <unordered_set>

std::string power(int a, int b);
std::vector<int> num2vector(int n);

int Problem() {

	long long limit = 100;
	std::string add;
	std::unordered_set<std::string> data;
	for (long long a = 2; a <= limit; a++) {
		for (long long b = 2; b <= limit; b++) {
			add = power(a, b);
			data.insert(add);
		}
	}

	return data.size();
}

std::string power(int a, int b) {
	std::string res;

	std::vector<int> digits;
	std::vector<int> number = num2vector(a);
	for (int i = 1; i < b; i++) {
		for (int j = 0; j < number.size(); j++) {
			number[j] *= a;
		}

		for (int j = 0; j < number.size(); j++) {
			if (number[j] >= 10) {
				digits = num2vector(number[j]);

				number[j] = digits[0];

				while (j + digits.size() > number.size()) {
					number.push_back(0);
				}

				for (int k = 1; k < digits.size(); k++) {
					number[j + k] += digits[k];
				}
			}
		}
	}

	for (int i = number.size() - 1; i >= 0; i--) {
		res.append(std::to_string(number[i]));
	}

	return res;
}

std::vector<int> num2vector(int n) {
	std::vector<int> digits;
	while (n > 0) {
		digits.push_back(n % 10);
		n /= 10;
	}
	return digits;
}